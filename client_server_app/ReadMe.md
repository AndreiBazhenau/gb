Клиент-серверные приложения на Python
---

https://gb.ru/courses/216

**Поочерёдный запуск приложений из консоли**:

- `python hw_3_client.py 127.0.0.1 7777`
- `python hw_3_server.py 127.0.0.1 7777`

**Одновременный запуск обоих скриптов из консоли**

```python
python server.py 127.0.0.1 7777 & python client.py 127.0.0.1 7777 &
```

**Или (самые удобные способы) для одновременного запуска:**

- создать `compaund run configuration` в PyCharm
- создать multi run через плагин Multirun

## Урок 1. Концепции хранения информации

**Практическое задание**

1. Каждое из слов «разработка», «сокет», «декоратор» представить в строковом формате и проверить тип и содержание соответствующих переменных. Затем с помощью онлайн-конвертера преобразовать строковые представление в формат Unicode и также проверить тип и содержимое переменных.
2. Каждое из слов «class», «function», «method» записать в байтовом типе без преобразования в последовательность кодов (не используя методы encode и decode) и определить тип, содержимое и длину соответствующих переменных.
3. Определить, какие из слов «attribute», «класс», «функция», «type» невозможно записать в байтовом типе.
4. Преобразовать слова «разработка», «администрирование», «protocol», «standard» из строкового представления в байтовое и выполнить обратное преобразование (используя методы encode и decode).
5. Выполнить пинг веб-ресурсов yandex.ru, youtube.com и преобразовать результаты из байтовового в строковый тип на кириллице.
6. Создать текстовый файл test_file.txt, заполнить его тремя строками: «сетевое программирование», «сокет», «декоратор». Проверить кодировку файла по умолчанию. Принудительно открыть файл в формате Unicode и вывести его содержимое.

## Урок 2. Файловое хранение данных

*Введение в файловое хранение данных. Использование файлов в формате CSV при сохранении данных. Файлы JSON как средство обмена данными. Работа с YAML-файлами при обработке и сохранении данных*.

**Практическое задание**

1. Задание на закрепление знаний по модулю **CSV**. Написать скрипт, осуществляющий выборку определенных данных из файлов **info_1.txt**, **info_2.txt**, **info_3.txt** и формирующий новый «отчетный» файл в формате **CSV**. Для этого:
   
   1. Создать функцию **get_data()**, в которой в цикле осуществляется перебор файлов с данными, их открытие и считывание данных. В этой функции из считанных данных необходимо с помощью регулярных выражений извлечь значения параметров «Изготовитель системы», «Название ОС», «Код продукта», «Тип системы». Значения каждого параметра поместить в соответствующий список. Должно получиться четыре списка — например, **os_prod_list**, **os_name_list**, **os_code_list**, **os_type_list**. В этой же функции создать главный список для хранения данных отчета — например, **main_data** — и поместить в него названия столбцов отчета в виде списка: «Изготовитель системы», «Название ОС», «Код продукта», «Тип системы». Значения для этих столбцов также оформить в виде списка и поместить в файл **main_data** (также для каждого файла);
   2. Создать функцию **write_to_csv()**, в которую передавать ссылку на CSV-файл. В этой функции реализовать получение данных через вызов функции **get_data()**, а также сохранение подготовленных данных в соответствующий CSV-файл;
   3. Проверить работу программы через вызов функции **write_to_csv()**.

2. Задание на закрепление знаний по модулю **json**. Есть файл **orders** в формате **JSON** с информацией о заказах. Написать скрипт, автоматизирующий его заполнение данными. Для этого:
   
   1. Создать функцию **write_order_to_json()**, в которую передается 5 параметров — товар (**item**), количество (**quantity**), цена (**price**), покупатель (**buyer**), дата (**date**). Функция должна предусматривать запись данных в виде словаря в файл **orders.json**. При записи данных указать величину отступа в 4 пробельных символа;
   2. Проверить работу программы через вызов функции **write_order_to_json()** с передачей в нее значений каждого параметра.

3. Задание на закрепление знаний по модулю **yaml**. Написать скрипт, автоматизирующий сохранение данных в файле YAML-формата. Для этого:
   
   1. Подготовить данные для записи в виде словаря, в котором первому ключу соответствует список, второму — целое число, третьему — вложенный словарь, где значение каждого ключа — это целое число с юникод-символом, отсутствующим в кодировке ASCII (например, €);
   2. Реализовать сохранение данных в файл формата YAML — например, в файл **file.yaml**. При этом обеспечить стилизацию файла с помощью параметра **default_flow_style**, а также установить возможность работы с юникодом: **allow_unicode = True**;
   3. Реализовать считывание данных из созданного файла и проверить, совпадают ли они с исходными.

## Урок 3. Основы сетевого программирования

*Введение в сетевое взаимодействие, его протоколы. Сокеты как основа работы сетевых приложений. Протоколы обмена в курсовом проекте.*

**Практическое задание**

1. Реализовать простое клиент-серверное взаимодействие по протоколу JIM (JSON instant messaging):
   1. клиент отправляет запрос серверу;
   2. сервер отвечает соответствующим кодом результата.

Клиент и сервер должны быть реализованы в виде отдельных скриптов, содержащих соответствующие функции.

**Функции клиента**:

- сформировать presence-сообщение;
- отправить сообщение серверу;
- получить ответ сервера;
- разобрать сообщение сервера;
- параметры командной строки скрипта **client.py <addr> [<port>]**:
  - **addr** — ip-адрес сервера;
  - **port** — tcp-порт на сервере, по умолчанию 7777.

**Функции сервера**:

- принимает сообщение клиента;
- формирует ответ клиенту;
- отправляет ответ клиенту;
- имеет параметры командной строки:
  - **-p <port>** — TCP-порт для работы (по умолчанию использует 7777);
  - **-a <addr>** — IP-адрес для прослушивания (по умолчанию слушает все доступные адреса).

## Урок 4. Основы тестирования

*Введение в тестирование. Оператор assert. Модульное тестирование и модуль unittest*

**Практическое задание**

1. Для всех функций из урока 3 написать тесты с использованием unittest. Они должны быть оформлены в отдельных скриптах с префиксом test_ в имени файла (например, test_client.py).
2. (*) Написать тесты для домашних работ из курса «Python 1».

## Урок 5. Логирование

*Журналирование событий и модуль logging*

**Практическое задание**

Для проекта «Мессенджер» реализовать логирование с использованием модуля **logging**:

1. В директории проекта создать каталог **log**, в котором для клиентской и серверной сторон в отдельных модулях формата **client_log_config.py** и **server_log_config.py** создать логгеры;
2. В каждом модуле выполнить настройку соответствующего логгера по следующему алгоритму:
   a. Создание именованного логгера;
   b. Сообщения лога должны иметь следующий формат: **"<дата-время> <уровень-важности> <имя_модуля> <сообщение>"**;
   c. Журналирование должно производиться в лог-файл;
   d. На стороне сервера необходимо настроить ежедневную ротацию лог-файлов.  
3. Реализовать применение созданных логгеров для решения двух задач:
   a Журналирование обработки исключений **try/except**. Вместо функции **print()** использовать журналирование и обеспечить вывод служебных сообщений в лог-файл;
   b. Журналирование функций, исполняемых на серверной и клиентской сторонах при работе мессенджера.

## Урок 6. Декораторы и продолжение работы с сетью

*Декоратор. Декоратор с параметром. Сетевое программирование (продолжение)*

**Практическое задание**

1. Продолжая задачу логирования, реализовать декоратор `@log`, фиксирующий обращение к декорируемой функции. Он сохраняет ее имя и аргументы.
2. В декораторе `@log` реализовать фиксацию функции, из которой была вызвана декорированная. Если имеется такой код:

```python
@log
def func_z(): 
    pass

def main(): 
    func_z()
```

...в логе должна быть отражена информация:

`"<дата-время> функция func_z() вызвана из функции main"`

Для клиента логгер реализовать в виде функции, а для сервера в виде класса.
